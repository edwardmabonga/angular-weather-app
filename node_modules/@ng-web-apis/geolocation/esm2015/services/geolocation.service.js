/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { finalize, shareReplay } from 'rxjs/operators';
import { GEOLOCATION } from '../tokens/geolocation';
import { POSITION_OPTIONS } from '../tokens/geolocation-options';
import { GEOLOCATION_SUPPORT } from '../tokens/geolocation-support';
import * as i0 from "@angular/core";
import * as i1 from "../tokens/geolocation";
import * as i2 from "../tokens/geolocation-support";
import * as i3 from "../tokens/geolocation-options";
// @dynamic
export class GeolocationService extends Observable {
    /**
     * @param {?} geolocationRef
     * @param {?} geolocationSupported
     * @param {?} positionOptions
     */
    constructor(geolocationRef, geolocationSupported, positionOptions) {
        /** @type {?} */
        let watchPositionId = 0;
        super(subscriber => {
            if (!geolocationSupported) {
                subscriber.error('Geolocation is not supported in your browser');
            }
            watchPositionId = geolocationRef.watchPosition(position => subscriber.next(position), positionError => subscriber.error(positionError), positionOptions);
        });
        return (/** @type {?} */ (this.pipe(finalize(() => geolocationRef.clearWatch(watchPositionId)), shareReplay({ bufferSize: 1, refCount: true }))));
    }
}
GeolocationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
GeolocationService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [GEOLOCATION,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [GEOLOCATION_SUPPORT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [POSITION_OPTIONS,] }] }
];
/** @nocollapse */ GeolocationService.ngInjectableDef = i0.defineInjectable({ factory: function GeolocationService_Factory() { return new GeolocationService(i0.inject(i1.GEOLOCATION), i0.inject(i2.GEOLOCATION_SUPPORT), i0.inject(i3.POSITION_OPTIONS)); }, token: GeolocationService, providedIn: "root" });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvbG9jYXRpb24uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZy13ZWItYXBpcy9nZW9sb2NhdGlvbi8iLCJzb3VyY2VzIjpbInNlcnZpY2VzL2dlb2xvY2F0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2pELE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDaEMsT0FBTyxFQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyRCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDbEQsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sK0JBQStCLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sK0JBQStCLENBQUM7Ozs7OztBQU1sRSxNQUFNLE9BQU8sa0JBQW1CLFNBQVEsVUFBb0I7Ozs7OztJQUN4RCxZQUN5QixjQUEyQixFQUNuQixvQkFBNkIsRUFFMUQsZUFBZ0M7O1lBRTVCLGVBQWUsR0FBRyxDQUFDO1FBRXZCLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNmLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtnQkFDdkIsVUFBVSxDQUFDLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO2FBQ3BFO1lBRUQsZUFBZSxHQUFHLGNBQWMsQ0FBQyxhQUFhLENBQzFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFDckMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUNoRCxlQUFlLENBQ2xCLENBQUM7UUFDTixDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sbUJBQUEsSUFBSSxDQUFDLElBQUksQ0FDWixRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUMxRCxXQUFXLENBQUMsRUFBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUMvQyxFQUFzQixDQUFDO0lBQzVCLENBQUM7OztZQTVCSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7Ozs7NENBR1EsTUFBTSxTQUFDLFdBQVc7MENBQ2xCLE1BQU0sU0FBQyxtQkFBbUI7NENBQzFCLE1BQU0sU0FBQyxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdCwgSW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtmaW5hbGl6ZSwgc2hhcmVSZXBsYXl9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7R0VPTE9DQVRJT059IGZyb20gJy4uL3Rva2Vucy9nZW9sb2NhdGlvbic7XG5pbXBvcnQge1BPU0lUSU9OX09QVElPTlN9IGZyb20gJy4uL3Rva2Vucy9nZW9sb2NhdGlvbi1vcHRpb25zJztcbmltcG9ydCB7R0VPTE9DQVRJT05fU1VQUE9SVH0gZnJvbSAnLi4vdG9rZW5zL2dlb2xvY2F0aW9uLXN1cHBvcnQnO1xuXG4vLyBAZHluYW1pY1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgR2VvbG9jYXRpb25TZXJ2aWNlIGV4dGVuZHMgT2JzZXJ2YWJsZTxQb3NpdGlvbj4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KEdFT0xPQ0FUSU9OKSBnZW9sb2NhdGlvblJlZjogR2VvbG9jYXRpb24sXG4gICAgICAgIEBJbmplY3QoR0VPTE9DQVRJT05fU1VQUE9SVCkgZ2VvbG9jYXRpb25TdXBwb3J0ZWQ6IGJvb2xlYW4sXG4gICAgICAgIEBJbmplY3QoUE9TSVRJT05fT1BUSU9OUylcbiAgICAgICAgcG9zaXRpb25PcHRpb25zOiBQb3NpdGlvbk9wdGlvbnMsXG4gICAgKSB7XG4gICAgICAgIGxldCB3YXRjaFBvc2l0aW9uSWQgPSAwO1xuXG4gICAgICAgIHN1cGVyKHN1YnNjcmliZXIgPT4ge1xuICAgICAgICAgICAgaWYgKCFnZW9sb2NhdGlvblN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoJ0dlb2xvY2F0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdhdGNoUG9zaXRpb25JZCA9IGdlb2xvY2F0aW9uUmVmLndhdGNoUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPT4gc3Vic2NyaWJlci5uZXh0KHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkVycm9yID0+IHN1YnNjcmliZXIuZXJyb3IocG9zaXRpb25FcnJvciksXG4gICAgICAgICAgICAgICAgcG9zaXRpb25PcHRpb25zLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZShcbiAgICAgICAgICAgIGZpbmFsaXplKCgpID0+IGdlb2xvY2F0aW9uUmVmLmNsZWFyV2F0Y2god2F0Y2hQb3NpdGlvbklkKSksXG4gICAgICAgICAgICBzaGFyZVJlcGxheSh7YnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWV9KSxcbiAgICAgICAgKSBhcyBHZW9sb2NhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuIl19